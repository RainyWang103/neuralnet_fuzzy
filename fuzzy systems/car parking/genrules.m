function rulebase=genrules(iodata,A,B,C);
% rulebase=genrules(iodata)
% To generate rules for parking a car from input-output data using the
% Learning-from-Examples approach.
% Input:
% iodata  is a matrix with 4 columns [x y phi theta] generated by a human driver
% A  Each row of A contains the parameters of a triangular mf for input x
% B  Each row of B contains the parameters of a triangular mf for input phi
% C  Each row of C contains the parameters of a triangular mf for variable theta         
% Output:
% rulebase is a matrix each row of each represents a rule of the form
%          IF x is iA and phi is iB THEN theta is iC
% where iA, iB and iC are fuzzy sets with mf's taken from the rows A,B,C  

% Written by YS Hung (11/2000).
% Last modified 8/11/2002.

[M,dum]=size(iodata);  % M is the number of input-output pairs
[nA,dum]=size(A);      % nA is the no. of mf's for x
[nB,dum]=size(B);      % nB is the no. of mf's for phi
[nC,dum]=size(C);      % nC is the no. of mf's for theta
rulebase=[];

for k=1:M     % extract the kth input-output pair from iodata
   x=iodata(k,1); phi=iodata(k,3); theta=iodata(k,4);

for i=1:nA  % evaluate the mf's of A at x and identify the row with max membership
   Ax=evalmf(x,A(i,:),'trimf');
   if i==1,
      Axmax=Ax; iA=1;
   elseif i>1 & Ax>Axmax,
      Axmax=Ax; iA=i;
   end
end
for i=1:nB  % evaluate the mf's of B at phi and identify the row with max membership
   Bphi=evalmf(phi,B(i,:),'trimf');
   if i==1,
      Bphimax=Bphi; iB=1;
   elseif i>1 & Bphi>Bphimax,
      Bphimax=Bphi; iB=i;
   end
end
for i=1:nC  % evaluate the mf's of C at theta and identify the row with max membership
   Ctheta=evalmf(theta,C(i,:),'trimf');
   if i==1,
      Cthetamax=Ctheta; iC=1;
   elseif i>1 & Ctheta>Cthetamax,
      Cthetamax=Ctheta; iC=i;
   end
end
Dk=Axmax*Bphimax*Cthetamax;  % Dk is the degree of reliability of the kth rule
rulebase=[rulebase; iA iB iC Dk 1]; % add kth rule to rule base
end

% remove conflicting rules: if two rules have the same antecedent, retain the
% one with the larger degree of reliability

RulePter=zeros(nB,nA);
Reliability=zeros(nB,nA);
for k=1:M  % work through the raw rule base one by one
   j=rulebase(k,1);
   i=rulebase(k,2);
   Dk=rulebase(k,4);
   if Dk>Reliability(i,j),
      RulePter(i,j)=k;
      Reliability(i,j)=Dk;
   end
end

vec=RulePter(:);  % turn lookup table for rule pointers into a vector
[sizevec,dum] = size(vec);
nrules=sum(vec>0); % only nonzeros entries correspond to rules
svec=sort(vec);    % so sort the rule pointer vector
ruleidx=svec(sizevec-nrules+1:sizevec);  % and retain only nonzeros entries
rulebase=rulebase(ruleidx,:); % extract the retained rules from the raw rule base

% replace reliability measures by 1's in the final rulebase
rulebase(:,4)=1;